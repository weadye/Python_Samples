import numpy as np

# 通过索引访问二维数组某一行或某个元素
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(arr[2])  # [7 8 9]
print(arr[0][2])  # 3
print(arr[0, 2])  # 3 普通python数组不能用
print('')

# 对更高维数组的访问和操作
arr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
print(arr[0])  # 结果是个二维数组
'''
[[1 2 3]
 [4 5 6]]
 '''
print(arr[1, 0])  # 结果是个一维数组: [7 8 9]
old_values = arr[0].copy()
arr[0] = 42
print(arr)
'''
[[[42 42 42]  [42 42 42]]
 [[ 7  8  9]  [10 11 12]]]
'''
arr[0] = old_values
print(arr)
'''
[[[ 1  2  3]  [ 4  5  6]]
[[ 7  8  9]  [10 11 12]]]
'''
print('')

# 使用切片访问和操作数组
arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
print(arr[1:6])  # [2 3 4 5 6] 打印arr[1]到arr[5]，和list切片不同，这里是引用，不会给b新的内存
b = arr[1:6]
b[0] = 99  # b[0]被赋值后，arr对应的位置的值也会被改
print(b)  # [99  3  4  5  6]
print(arr)  # [ 1 99  3  4  5  6  7  8  9 10]
b = arr[1:6].copy()  # 用copy的形式来做切片，会给b开辟新的内存
b[1] = 99  # b[0]被赋值后，arr不会被影响
print(b)  # [99 99  4  5  6]
print(arr)  # [ 1 99  3  4  5  6  7  8  9 10]

arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(arr[:2], arr[:2].shape)  # 打印第1、2行
'''
[[1 2 3]
 [4 5 6]] (2, 3)
'''
print(arr[:2, 1:], arr[:2, 1:].shape)  # 打印第1、2行，第2、3列
'''
[[2 3]
 [5 6]] (2, 2)
'''
print(arr[:, 0], arr[:, 0].shape)  # 打印第1列所有元素
'''
[1 4 7] (3,)
'''
print(arr[:, :1], arr[:, :1].shape)  # 实质上还是打印第1列，但是由于:1的结果其实是[0]，所以结果与上一次有所差异
'''
[[1]
 [4]
 [7]] (3, 1)
'''
print(arr[0, :], arr[0, :].shape)  # 打印第1行
'''
[1 2 3] (3,)
'''
print(arr[0:1, :], arr[0:1, :].shape)  # 实质上还是打印第1行，但是由于0:1的结果其实是[0]，所以结果与上一次有所差异
'''
[[1 2 3]] (1, 3)
'''
arr[:2, 1:] = 0  # 第1、2行，第2、3列的元素设置为0
print(arr)
'''
[[1 0 0]
 [4 0 0]
 [7 8 9]]
'''
arr = np.array([[1, 5, 6], [8, 9, 4]])
print(arr[[0, 1], [1, 2]])  # [5 4] 取出了arr[0,1]和arr[1,2]
print(arr[[0, 1], [1, 2]].shape)  # (2,)

